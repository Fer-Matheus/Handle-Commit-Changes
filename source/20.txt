: "diff --git a/config/.gitignore b/config/.gitignore\nnew file mode 100644\nindex 0000000..5e56e04\n--- /dev/null\n+++ b/config/.gitignore\n@@ -0,0 +1 @@\n+/bin\ndiff --git a/config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java b/config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java\nindex 394931d..bcda80d 100644\n--- a/config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java\n+++ b/config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java\n@@ -17,7 +17,7 @@ import com.typesafe.config.ConfigRenderOptions;\n import com.typesafe.config.ConfigValue;\n import com.typesafe.config.ConfigValueType;\n \n-abstract class AbstractConfigObject extends AbstractConfigValue implements ConfigObject {\n+abstract class AbstractConfigObject extends AbstractConfigValue implements ConfigObject, Container {\n \n     final private SimpleConfig config;\n \n@@ -56,7 +56,8 @@ abstract class AbstractConfigObject extends AbstractConfigValue implements Confi\n     /**\n      * This looks up the key with no transformation or type conversion of any\n      * kind, and returns null if the key is not present. The object must be\n-     * resolved; use attemptPeekWithPartialResolve() if it is not.\n+     * resolved along the nodes needed to get the key or\n+     * ConfigException.NotResolved will be thrown.\n      *\n      * @param key\n      * @return the unmodified raw value or null\n@@ -78,67 +79,34 @@ abstract class AbstractConfigObject extends AbstractConfigValue implements Confi\n      *            key to look up\n      * @return the value of the key, or null if known not to exist\n      * @throws ConfigException.NotResolved\n-     *             if can't figure out key's value or can't know whether it\n-     *             exists\n+     *             if can't figure out key's value (or existence) without more\n+     *             resolving\n      */\n-    protected abstract AbstractConfigValue attemptPeekWithPartialResolve(String key);\n+    abstract AbstractConfigValue attemptPeekWithPartialResolve(String key);\n \n     /**\n-     * Looks up the path with no transformation, type conversion, or exceptions\n-     * (just returns null if path not found). Does however resolve the path, if\n-     * resolver != null.\n-     *\n-     * @throws NotPossibleToResolve\n-     *             if context is not null and resolution fails\n+     * Looks up the path with no transformation or type conversion. Returns null\n+     * if the path is not found; throws ConfigException.NotResolved if we need\n+     * to go through an unresolved node to look up the path.\n      */\n-    protected AbstractConfigValue peekPath(Path path, ResolveContext context) throws NotPossibleToResolve {\n-        return peekPath(this, path, context);\n+    protected AbstractConfigValue peekPath(Path path) {\n+        return peekPath(this, path);\n     }\n \n-    /**\n-     * Looks up the path. Doesn't do any resolution, will throw if any is\n-     * needed.\n-     */\n-    AbstractConfigValue peekPath(Path path) {\n+    private static AbstractConfigValue peekPath(AbstractConfigObject self, Path path) {\n         try {\n-            return peekPath(this, path, null);\n-        } catch (NotPossibleToResolve e) {\n-            throw new ConfigException.BugOrBroken(\n-                    \"NotPossibleToResolve happened though we had no ResolveContext in peekPath\");\n-        }\n-    }\n+            // we'll fail if anything along the path can't\n+            // be looked at without resolving.\n+            Path next = path.remainder();\n+            AbstractConfigValue v = self.attemptPeekWithPartialResolve(path.first());\n \n-    // as a side effect, peekPath() will have to resolve all parents of the\n-    // child being peeked, but NOT the child itself. Caller has to resolve\n-    // the child itself if needed.\n-    private static AbstractConfigValue peekPath(AbstractConfigObject self, Path path,\n-            ResolveContext context) throws NotPossibleToResolve {\n-        try {\n-            if (context != null) {\n-                // walk down through the path resolving only things along that\n-                // path, and then recursively call ourselves with no resolve\n-                // context.\n-                AbstractConfigValue partiallyResolved = context.restrict(path).resolve(self);\n-                if (partiallyResolved instanceof AbstractConfigObject) {\n-                    return peekPath((AbstractConfigObject) partiallyResolved, path, null);\n-                } else {\n-                    throw new ConfigException.BugOrBroken(\"resolved object to non-object \" + self\n-                            + \" to \" + partiallyResolved);\n-                }\n+            if (next == null) {\n+                return v;\n             } else {\n-                // with no resolver, we'll fail if anything along the path can't\n-                // be looked at without resolving.\n-                Path next = path.remainder();\n-                AbstractConfigValue v = self.attemptPeekWithPartialResolve(path.first());\n-\n-                if (next == null) {\n-                    return v;\n+                if (v instanceof AbstractConfigObject) {\n+                    return peekPath((AbstractConfigObject) v, next);\n                 } else {\n-                    if (v instanceof AbstractConfigObject) {\n-                        return peekPath((AbstractConfigObject) v, next, null);\n-                    } else {\n-                        return null;\n-                    }\n+                    return null;\n                 }\n             }\n         } catch (ConfigException.NotResolved e) {\n@@ -209,7 +177,8 @@ abstract class AbstractConfigObject extends AbstractConfigValue implements Confi\n     }\n \n     @Override\n-    abstract AbstractConfigObject resolveSubstitutions(ResolveContext context) throws NotPossibleToResolve;\n+    abstract AbstractConfigObject resolveSubstitutions(ResolveContext context, ResolveSource source)\n+            throws NotPossibleToResolve;\n \n     @Override\n     abstract AbstractConfigObject relativized(final Path prefix);\ndiff --git a/config/src/main/java/com/typesafe/config/impl/AbstractConfigValue.java b/config/src/main/java/com/typesafe/config/impl/AbstractConfigValue.java\nindex 9b6b1fd..1eb05c8 100644\n--- a/config/src/main/java/com/typesafe/config/impl/AbstractConfigValue.java\n+++ b/config/src/main/java/com/typesafe/config/impl/AbstractConfigValue.java\n@@ -68,9 +68,11 @@ abstract class AbstractConfigValue implements ConfigValue, MergeableValue {\n      *\n      * @param context\n      *            state of the current resolve\n+     * @param source\n+     *            where to look up values\n      * @return a new value if there were changes, or this if no changes\n      */\n-    AbstractConfigValue resolveSubstitutions(ResolveContext context)\n+    AbstractConfigValue resolveSubstitutions(ResolveContext context, ResolveSource source)\n             throws NotPossibleToResolve {\n         return this;\n     }\n@@ -79,6 +81,38 @@ abstract class AbstractConfigValue implements ConfigValue, MergeableValue {\n         return ResolveStatus.RESOLVED;\n     }\n \n+    protected static List<AbstractConfigValue> replaceChildInList(List<AbstractConfigValue> list,\n+            AbstractConfigValue child, AbstractConfigValue replacement) {\n+        int i = 0;\n+        while (i < list.size() && list.get(i) != child)\n+            ++i;\n+        if (i == list.size())\n+            throw new ConfigException.BugOrBroken(\"tried to replace \" + child + \" which is not in \" + list);\n+        List<AbstractConfigValue> newStack = new ArrayList<AbstractConfigValue>(list);\n+        if (replacement != null)\n+            newStack.set(i, replacement);\n+        else\n+            newStack.remove(i);\n+\n+        if (newStack.isEmpty())\n+            return null;\n+        else\n+            return newStack;\n+    }\n+\n+    protected static boolean hasDescendantInList(List<AbstractConfigValue> list, AbstractConfigValue descendant) {\n+        for (AbstractConfigValue v : list) {\n+            if (v == descendant)\n+                return true;\n+        }\n+        // now the expensive traversal\n+        for (AbstractConfigValue v : list) {\n+            if (v instanceof Container && ((Container) v).hasDescendant(descendant))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n     /**\n      * This is used when including one file in another; the included file is\n      * relativized to the path it's included into in the parent file. The point\ndiff --git a/config/src/main/java/com/typesafe/config/impl/ConfigConcatenation.java b/config/src/main/java/com/typesafe/config/impl/ConfigConcatenation.java\nindex 8cb1575..e4f031e 100644\n--- a/config/src/main/java/com/typesafe/config/impl/ConfigConcatenation.java\n+++ b/config/src/main/java/com/typesafe/config/impl/ConfigConcatenation.java\n@@ -22,7 +22,7 @@ import com.typesafe.config.ConfigValueType;\n  * concatenations of objects, but ConfigDelayedMerge should be used for that\n  * since a concat of objects really will merge, not concatenate.\n  */\n-final class ConfigConcatenation extends AbstractConfigValue implements Unmergeable {\n+final class ConfigConcatenation extends AbstractConfigValue implements Unmergeable, Container {\n \n     final private List<AbstractConfigValue> pieces;\n \n@@ -170,7 +170,7 @@ final class ConfigConcatenation extends AbstractConfigValue implements Unmergeab\n     }\n \n     @Override\n-    AbstractConfigValue resolveSubstitutions(ResolveContext context) throws NotPossibleToResolve {\n+    AbstractConfigValue resolveSubstitutions(ResolveContext context, ResolveSource source) throws NotPossibleToResolve {\n         if (ConfigImpl.traceSubstitutionsEnabled()) {\n             int indent = context.depth() + 2;\n             ConfigImpl.trace(indent - 1, \"concatenation has \" + pieces.size() + \" pieces:\");\n@@ -181,11 +181,16 @@ final class ConfigConcatenation extends AbstractConfigValue implements Unmergeab\n             }\n         }\n \n+        // Right now there's no reason to pushParent here because the\n+        // content of ConfigConcatenation should not need to replaceChild,\n+        // but if it did we'd have to do this.\n+        ResolveSource sourceWithParent = source; // .pushParent(this);\n+\n         List<AbstractConfigValue> resolved = new ArrayList<AbstractConfigValue>(pieces.size());\n         for (AbstractConfigValue p : pieces) {\n             // to concat into a string we have to do a full resolve,\n             // so unrestrict the context\n-            AbstractConfigValue r = context.unrestricted().resolve(p);\n+            AbstractConfigValue r = context.unrestricted().resolve(p, sourceWithParent);\n             if (ConfigImpl.traceSubstitutionsEnabled())\n                 ConfigImpl.trace(context.depth(), \"resolved concat piece to \" + r);\n             if (r == null) {\n@@ -215,6 +220,20 @@ final class ConfigConcatenation extends AbstractConfigValue implements Unmergeab\n         return ResolveStatus.UNRESOLVED;\n     }\n \n+    @Override\n+    public ConfigConcatenation replaceChild(AbstractConfigValue child, AbstractConfigValue replacement) {\n+        List<AbstractConfigValue> newPieces = replaceChildInList(pieces, child, replacement);\n+        if (newPieces == null)\n+            return null;\n+        else\n+            return new ConfigConcatenation(origin(), newPieces);\n+    }\n+\n+    @Override\n+    public boolean hasDescendant(AbstractConfigValue descendant) {\n+        return hasDescendantInList(pieces, descendant);\n+    }\n+\n     // when you graft a substitution into another object,\n     // you have to prefix it with the location in that object\n     // where you grafted it; but save prefixLength so\ndiff --git a/config/src/main/java/com/typesafe/config/impl/ConfigDelayedMerge.java b/config/src/main/java/com/typesafe/config/impl/ConfigDelayedMerge.java\nindex 206f18b..32a8ea6 100644\n--- a/config/src/main/java/com/typesafe/config/impl/ConfigDelayedMerge.java\n+++ b/config/src/main/java/com/typesafe/config/impl/ConfigDelayedMerge.java\n@@ -54,20 +54,19 @@ final class ConfigDelayedMerge extends AbstractConfigValue implements Unmergeabl\n     }\n \n     @Override\n-    AbstractConfigValue resolveSubstitutions(ResolveContext context)\n+    AbstractConfigValue resolveSubstitutions(ResolveContext context, ResolveSource source)\n             throws NotPossibleToResolve {\n-        return resolveSubstitutions(this, stack, context);\n+        return resolveSubstitutions(this, stack, context, source);\n     }\n \n     // static method also used by ConfigDelayedMergeObject\n-    static AbstractConfigValue resolveSubstitutions(ReplaceableMergeStack replaceable,\n-            List<AbstractConfigValue> stack, ResolveContext context) throws NotPossibleToResolve {\n+    static AbstractConfigValue resolveSubstitutions(ReplaceableMergeStack replaceable, List<AbstractConfigValue> stack,\n+            ResolveContext context, ResolveSource source) throws NotPossibleToResolve {\n         if (ConfigImpl.traceSubstitutionsEnabled()) {\n-            int indent = context.depth() + 2;\n-            ConfigImpl.trace(indent - 1, \"delayed merge stack has \" + stack.size() + \" items:\");\n+            ConfigImpl.trace(context.depth(), \"delayed merge stack has \" + stack.size() + \" items:\");\n             int count = 0;\n             for (AbstractConfigValue v : stack) {\n-                ConfigImpl.trace(indent, count + \": \" + v);\n+                ConfigImpl.trace(context.depth() + 1, count + \": \" + v);\n                 count += 1;\n             }\n         }\n@@ -75,91 +74,93 @@ final class ConfigDelayedMerge extends AbstractConfigValue implements Unmergeabl\n         // to resolve substitutions, we need to recursively resolve\n         // the stack of stuff to merge, and merge the stack so\n         // we won't be a delayed merge anymore. If restrictToChildOrNull\n-        // is non-null, we may remain a delayed merge though.\n+        // is non-null, or resolve options allow partial resolves,\n+        // we may remain a delayed merge though.\n \n         int count = 0;\n         AbstractConfigValue merged = null;\n-        for (AbstractConfigValue v : stack) {\n-            if (v instanceof ReplaceableMergeStack)\n-                throw new ConfigException.BugOrBroken(\n-                        \"A delayed merge should not contain another one: \" + replaceable);\n-\n-            boolean replaced = false;\n-            // we only replace if we have a substitution, or\n-            // value-concatenation containing one. The Unmergeable\n-            // here isn't a delayed merge stack since we can't contain\n-            // another stack (see assertion above).\n-            if (v instanceof Unmergeable) {\n-                // If, while resolving 'v' we come back to the same\n-                // merge stack, we only want to look _below_ 'v'\n+        for (AbstractConfigValue end : stack) {\n+            // the end value may or may not be resolved already\n+\n+            ResolveSource sourceForEnd;\n+\n+            if (end instanceof ReplaceableMergeStack)\n+                throw new ConfigException.BugOrBroken(\"A delayed merge should not contain another one: \" + replaceable);\n+            else if (end instanceof Unmergeable) {\n+                // the remainder could be any kind of value, including another\n+                // ConfigDelayedMerge\n+                AbstractConfigValue remainder = replaceable.makeReplacement(context, count + 1);\n+\n+                if (ConfigImpl.traceSubstitutionsEnabled())\n+                    ConfigImpl.trace(context.depth(), \"remainder portion: \" + remainder);\n+\n+                // If, while resolving 'end' we come back to the same\n+                // merge stack, we only want to look _below_ 'end'\n                 // in the stack. So we arrange to replace the\n                 // ConfigDelayedMerge with a value that is only\n                 // the remainder of the stack below this one.\n \n                 if (ConfigImpl.traceSubstitutionsEnabled())\n-                    ConfigImpl.trace(context.depth() + 1, \"because item \" + count\n-                            + \" in this stack is unresolved, resolving it can only look at remaining \"\n-                            + (stack.size() - count - 1) + \" items\");\n-                context.source().replace((AbstractConfigValue) replaceable,\n-                        replaceable.makeReplacer(count + 1));\n-                replaced = true;\n-            }\n+                    ConfigImpl.trace(context.depth(), \"building sourceForEnd\");\n \n-            AbstractConfigValue resolved;\n-            try {\n+                // we resetParents() here because we'll be resolving \"end\"\n+                // against a root which does NOT contain \"end\"\n+                sourceForEnd = source.replaceWithinCurrentParent((AbstractConfigValue) replaceable, remainder);\n+\n+                if (ConfigImpl.traceSubstitutionsEnabled())\n+                    ConfigImpl.trace(context.depth(), \"  sourceForEnd before reset parents but after replace: \"\n+                            + sourceForEnd);\n+\n+                sourceForEnd = sourceForEnd.resetParents();\n+            } else {\n                 if (ConfigImpl.traceSubstitutionsEnabled())\n-                    ConfigImpl.trace(context.depth() + 1, \"resolving item \" + count + \" in merge stack of \"\n-                            + stack.size());\n-                resolved = context.resolve(v);\n-            } finally {\n-                if (replaced)\n-                    context.source().unreplace((AbstractConfigValue) replaceable);\n+                    ConfigImpl\n+                            .trace(context.depth(), \"will resolve end against the original source with parent pushed\");\n+\n+                sourceForEnd = source.pushParent(replaceable);\n             }\n \n-            if (resolved != null) {\n+            if (ConfigImpl.traceSubstitutionsEnabled()) {\n+                ConfigImpl.trace(context.depth(), \"sourceForEnd      =\" + sourceForEnd);\n+            }\n+\n+            if (ConfigImpl.traceSubstitutionsEnabled())\n+  ",